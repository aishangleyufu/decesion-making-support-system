%非线性迭代部分最小二乘算法（具体算法实现可参见Nipals算法流程）
function [P,B,Q,T,Ws,a] = nipals_Linear(X,Y,h)%对一般X,Y数据集，求参数P,B,Q,a――――――这个函数终于改对了！
%function [P, B, C, a] = nipals(X,Y,h)%对一般X,Y数据集，求参数P,B,Q,a
%-----------------------------------------------------------------
%E0 = X; F0 = Y;
[m] = size(X,2);
[E0, F0] = scale(X,Y);
%[E0, F0] = scale_add(X,y);
%----------------------------------------------------------------
%[nE0,mE0]=size(E0);

u(:,1) = F0(:,1);
%size(E0')
%size(u(:,1))
W(:,1) = (E0'*u(:,1))/(u(:,1)'*u(:,1));
W(:,1) = W(:,1)/norm(W(:,1));

%T(:,1) = (E0*W(:,1));
T(:,1) = (E0*W(:,1))/(W(:,1)'*W(:,1));

Q(:,1) = (F0'*T(:,1))/(T(:,1)'*T(:,1));
Q(:,1) = Q(:,1)/norm(Q(:,1));
%Q(:,1) = 1;%nipals算法说得好，在单输出的情况下，Q(:,i)可以直接置1.而之前是通式，那为什么不会出现在某一点时Q为非数即norm(Q(:,i))为0，相当于Q(:,i)很小。可能是在非线性时效果没那么好，不会使Q(:,i)那么小吧？可以考察一下。
%在非线性的情况下，Q(:,i)也是皆为1的。
%这个以前没注意，可以研究一下在什么情况下Q(:,i)会很小以致Q(:,i)=Q(:,i)/norm(Q(:,i))为非数？
%C(:,1) = (F0'*T(:,1))/(T(:,1)'*T(:,1));%这个与下面的Q(:,1)是什么关系？Q(:,1)不是重复了么？可以试着修改一下。
%C(:,1) = (F0(:,1)'*T(:,1))/(T(:,1)'*T(:,1));%用这个表示则建模效果非常差！
%C(:,1) = C(:,1)/norm(C(:,1));

u(:,1) = (F0*Q(:,1))/(Q(:,1)'*Q(:,1));
%u(:,1) = (F0*C(:,1))/(C(:,1)'*C(:,1));
%u(:,1) = (F0(:,1)*C(:,1))/(C(:,1)'*C(:,1));

P(:,1) = (E0'*T(:,1))/(T(:,1)'*T(:,1));
%Q(:,1) = (F0'*T(:,1))/(u(:,1)'*u(:,1));%
%Q(:,1) = (F0(:,1)'*T(:,1))/(u(:,1)'*u(:,1));%_该条不要

%b(1) = (u(:,1)'*u(:,1))/(T(:,1)'*T(:,1));
b(1) = (u(:,1)'*T(:,1))/(T(:,1)'*T(:,1));
E(:,:,1) = E0-T(:,1)*P(:,1)';

%F=b(1)*T(:,1)*Q(:,1)';
%[nf,mf]=size(F)
%F(:,1:4) = F0-b(1)*T(:,1)*Q(:,1)';

F(:,:,1) = F0-b(1)*T(:,1)*Q(:,1)';
%F(:,1) = F0-b(1)*T(:,1)*Q(:,1)';%王道――表示如果有尝试失败则最后回归之处
%F(:,1) = F0-b(1)*T(:,1)*C(:,1)';
%F(:,1) = F0(:,1)-b(1)*T(:,1)*Q(:,1)';

%[n,m] = size(b(1)*T(:,1)*Q(:,1)');%200*size(F0,2)
%F(:,:,1) = F0-b(1)*T(:,1)*Q(:,1)';
%FF = F(:,:,1);

for i = 2:h
    
    FF = F(:,:,i-1);%恰好都是是列向量，似乎才可以，要不然非出差不可。
    u(:,i) = FF;
    %u(:,i) = FF(:,1);
    %u(:,i) = F(:,i-1);%王道――表示如果有尝试失败则最后回归之处%恰好Y是列向量，似乎才可以，要不然非出差不可。但是也得试试按照书上思路纠正一下。
    
    W(:,i) = (E(:,:,i-1)'*u(:,i))/(u(:,i)'*u(:,i));
    W(:,i) = W(:,i)/norm(W(:,i));
    
    T(:,i) = (E(:,:,i-1)*W(:,i));
    
    %QQ(:,i) = (F(:,i-1)'*T(:,i))/(T(:,i)'*T(:,i));
    %Q(:,i) = QQ(:,i)/norm(QQ(:,i));
    
    %Q(:,i) = (F(:,:,i-1)'*T(:,i))/(T(:,i)'*T(:,i));
    %Q(:,i) = Q(:,i)/norm(Q(:,i));
    Q(:,i) = 1;%
    %C(:,i) = (F(:,:,i-1)'*T(:,i))/(T(:,i)'*T(:,i));
    %C(:,i) = C(:,i)/norm(C(:,i));
    
    u(:,i) = (F(:,:,i-1)*Q(:,i))/(Q(:,i)'*Q(:,i));
    %u(:,i) = (F(:,(i-1))*C(:,i))/(C(:,i)'*C(:,i));

    P(:,i) = (E(:,:,i-1)'*T(:,i))/(T(:,i)'*T(:,i));
    %Q(:,i) = (F(:,i-1)'*T(:,i))/(u(:,i)'*u(:,i));
    
    %b(i) = (u(:,i)'*u(:,i))/(T(:,i)'*T(:,i));
    b(i) = (u(:,i)'*T(:,i))/(T(:,i)'*T(:,i));
    E(:,:,i) = E(:,:,i-1)-T(:,i)*P(:,i)';
    F(:,:,i) = F(:,:,i-1)-b(i)*T(:,i)*Q(:,i)';
    %F(:,i) = F(:,i-1)-b(i)*T(:,i)*Q(:,i)';%王道――表示如果有尝试失败则最后回归之处
   % F(:,i) = F(:,i-1)-b(i)*T(:,i)*C(:,i)';
end
%u;
%F;
B = diag(b);

%-------------------------------------------------------------------

Ws(:,1) = W(:,1);

for j = 2:h
    w = eye(m);
    for k = 1:(j-1)
        w = w*(eye(m)-W(:,k)*P(:,k)');
    end
    
    Ws(:,j) = w*W(:,j);
end
%[nWs,mWs] = size(Ws);
%[nB,mB] = size(B);
%[nQ,mQ] = size(Q);
a = Ws*B*Q';
%a = Ws*B*C';


end
%--------------------------------------------------------------------



